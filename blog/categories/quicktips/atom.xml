<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quicktips | jtimberman's Code Blog]]></title>
  <link href="http://jtimberman.housepub.org/blog/categories/quicktips/atom.xml" rel="self"/>
  <link href="http://jtimberman.housepub.org/"/>
  <updated>2015-01-13T12:04:19-07:00</updated>
  <id>http://jtimberman.housepub.org/</id>
  <author>
    <name><![CDATA[Joshua Timberman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Testing Conditionals in ChefSpec]]></title>
    <link href="http://jtimberman.housepub.org/blog/2015/01/12/quick-tip-testing-conditionals-in-chefspec/"/>
    <updated>2015-01-12T14:07:06-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2015/01/12/quick-tip-testing-conditionals-in-chefspec</id>
    <content type="html"><![CDATA[<p>This tip is brought to you by the <a href="https://supermarket.chef.io/cookbooks/homebrew">homebrew</a> cookbook.</p>

<p><a href="http://sethvargo.github.io/chefspec/">ChefSpec</a> is a great way to create tests for Chef recipes to catch regressions. Sometimes recipes end up having branching conditional logic that can have very different outcomes based on external factors &ndash; attributes, existing system state, or cross-platform support.</p>

<p>The homebrew cookbook only supports OS X, so we don&rsquo;t have cross-platform support to test there. However, its default recipe has four conditionals to test. You can read the entire <a href="https://github.com/opscode-cookbooks/homebrew/blob/master/spec/recipes/default_spec.rb">default_spec.rb</a> for full context, I&rsquo;m going to focus on just one aspect here:</p>

<ul>
<li>Installing homebrew should only happen if the <code>brew</code> binary does not exist.</li>
</ul>


<p>This is a common use case in Chef recipes. The best way to go about converging your node to the desired state involves running some arbitrary command. In this case, it&rsquo;s the installation of Homebrew itself. Normally for installations we want to use an idempotent, convergent resource like <code>package</code>. However, since homebrew is to be our package management system, we have to do something else. As it turns out the homebrew project provides an installation script and that script will install a binary, <code>/usr/local/bin/brew</code>. We will assume that if Chef converged on a node after running the script, and the <code>brew</code> binary exists, then we don&rsquo;t need to attempt reinstallation. There&rsquo;s more robust ways to go about it (e.g., running <code>brew</code> gives some desired output), but this works for example purposes today.</p>

<p>From <a href="https://github.com/opscode-cookbooks/homebrew/blob/master/recipes/default.rb">the recipe</a>, here&rsquo;s the resource:</p>

<p><code>ruby
execute 'install homebrew' do
  command homebrew_go
  user node['homebrew']['owner'] || homebrew_owner
  not_if { ::File.exist? '/usr/local/bin/brew' }
end
</code></p>

<p><code>command</code> is a script, called <code>homebrew_go</code>, which is a local variable set to a path in <code>Chef::Config[:file_cache_path]</code>. It is retrieved in the recipe with <code>remote_file</code>. The resource used to have <code>execute homebrew_go</code>, but when ChefSpec runs, it does so in a random temporary directory, which we cannot predict the name.</p>

<p>The astute observer will note that the <code>user</code> parameter has another conditional (designated by the <code>||</code>). That&rsquo;s actually the subject of another post. In this post, I&rsquo;m concerned only with testing the guard, <code>not_if</code>.</p>

<p>The <code>not_if</code> is a Ruby block, which means the Ruby code is evaluated inline during the Chef run. How we go about testing that is the subject of this post.</p>

<p>First, we need to mock the return result of sending the <code>#exist?</code> method to the <code>File</code> class. There are two reasons. First, we want to control the conditional so we can write a test for each outcome. Second, someone running the test (like me) might have already installed homebrew on their local system (which I have), and so <code>/usr/local/bin/brew</code> will exist. To do this, in our context, we have a <code>before</code> block that stubs the return to false:</p>

<p><code>ruby
before(:each) do
  allow_any_instance_of(Chef::Resource).to receive(:homebrew_owner).and_return('vagrant')
  allow_any_instance_of(Chef::Recipe).to receive(:homebrew_owner).and_return('vagrant')
  allow(File).to receive(:exist?).and_return(false)
  stub_command('which git').and_return(true)
end
</code></p>

<p>There&rsquo;s some other mocked values here. I&rsquo;ll talk about the <code>vagrant</code> user for <code>homebrew_owner</code> in a moment, though again, that&rsquo;s the subject of another post.</p>

<p>The actual spec will test that the installation script will actually get executed when we run chef, and as the <code>vagrant</code> user.</p>

<p>```ruby
it &lsquo;runs homebrew installation as the default user&rsquo; do
  expect(chef_run).to run_execute(&lsquo;install homebrew&rsquo;).with(</p>

<pre><code>:user =&gt; 'vagrant'
</code></pre>

<p>  )
end
```</p>

<p>When rspec runs, we see this is the case:</p>

<p>```
homebrew::default
  default user</p>

<pre><code>runs homebrew installation as the default user
</code></pre>

<p>```</p>

<p>If I didn&rsquo;t mock the user, it would be <code>jtimberman</code>, as that is the user that is running Chef via rspec/ChefSpec. The test would fail. If you&rsquo;re looking at the full file, there&rsquo;s some other details we&rsquo;re going to look at shortly. If I didn&rsquo;t mock the return for <code>File.exist?</code>, the execute wouldn&rsquo;t run at all.</p>

<p>To test what happens when <code>/usr/local/bin/brew</code> exists, I set up a new context in rspec, and create a new <code>before</code> block.</p>

<p>```ruby
context &lsquo;/usr/local/bin/brew exists&rsquo; do
  before(:each) do</p>

<pre><code>allow(File).to receive(:exist?).and_return(true)
stub_command('which git').and_return(true)
</code></pre>

<p>  end</p>

<p>  it &lsquo;does not run homebrew installation&rsquo; do</p>

<pre><code>expect(chef_run).to_not run_execute('install homebrew')
</code></pre>

<p>  end
end
```</p>

<p>We don&rsquo;t need the <code>vagrant</code> mocks earlier, but we do need to stub <code>File.exist?</code>. This test would pass on my system without it, but not on, e.g., a Linux system that doesn&rsquo;t have homebrew.</p>

<p>Then running rspec, we see:</p>

<p>```
homebrew::default
  /usr/local/bin/brew exists</p>

<pre><code>does not run homebrew installation
</code></pre>

<p>  default user</p>

<pre><code>runs homebrew installation as the default user
</code></pre>

<p>```</p>

<p>In a coming post, I will walk through the conditionals related to the <code>homebrew_owner</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Serverspec spec_helper in Test Kitchen]]></title>
    <link href="http://jtimberman.housepub.org/blog/2014/12/31/quick-tip-serverspec-spec-helper-in-test-kitchen/"/>
    <updated>2014-12-31T16:01:23-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2014/12/31/quick-tip-serverspec-spec-helper-in-test-kitchen</id>
    <content type="html"><![CDATA[<p>Recently, I&rsquo;ve started refactoring some <a href="https://supermarket.chef.io/cookbooks/daemontools">old</a> <a href="https://supermarket.chef.io/cookbooks/djbdns">cookbooks</a> <a href="https://supermarket.chef.io/cookbooks/ucspi-tcp">I wrote</a> ages ago. I&rsquo;m adding Serverspec coverage that can be run with <code>kitchen verify</code>. In this <a href="/blog/categories/quicktips">quicktip</a>, I&rsquo;ll describe how to create a <code>spec_helper</code> that can be used in all the specs. This is a convention used by <a href="http://pivotallabs.com/spec-helper/">many</a> in the Ruby community to add configuration for RSpec.</p>

<p>For Chef, we can run integration tests after convergence using <a href="http://kitchen.ci">Test Kitchen</a> using Serverspec. To do that, we need to require Serverspec, and then set its backend. In some cookbooks, the author/developer may have written <code>spec_helper</code> files in the various <code>test/integration/SUITE/serverspec/</code> directories, but this will use a single shared file for them all. Let&rsquo;s get started.</p>

<p>In the <code>.kitchen.yml</code>, add the <code>data_path</code> configuration directive in the provisioner.</p>

<p><code>yaml
provisioner:
  name: chef_zero
  data_path: test/shared
</code></p>

<p>Then, create the <code>test/shared</code> directory in the cookbook, and create the <code>spec_helper.rb</code> in it.</p>

<p><code>sh
mkdir test/shared
$EDITOR test/shared/spec_helper.rb
</code></p>

<p>Minimally, it should look like this:</p>

<p>```ruby
require &lsquo;serverspec&rsquo;</p>

<p>set :backend, :exec
```</p>

<p>Then in your specs, for example <code>test/integration/default/serverspec/default_spec.rb</code>, require the <code>spec_helper</code>. On the instances under test, the file will be copied to <code>/tmp/kitchen/data/spec_helper.rb</code>.</p>

<p><code>ruby
require_relative '../../../kitchen/data/spec_helper'
</code></p>

<p>That&rsquo;s it, now when running <code>kitchen test</code>, or <code>kitchen verify</code> on a converged instance, the helper will be used.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Chef 12 Homebrew User Mixin]]></title>
    <link href="http://jtimberman.housepub.org/blog/2014/12/29/chef-12-homebrew-user-mixin/"/>
    <updated>2014-12-29T08:56:01-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2014/12/29/chef-12-homebrew-user-mixin</id>
    <content type="html"><![CDATA[<p>OS X is an interesting operating system. It is a Unix, but is primarily used for workstations. As such, many system settings can, and should, be done as a non-privileged user. Some tasks, however, require administrative privileges. OS X uses <code>sudo</code> to escalate privileges. This is done by a nice GUI pop-up requesting the user password when done through another GUI element. However, one must use <code>sudo $COMMAND</code> when working at the Terminal.</p>

<p>The <a href="http://brew.sh">Homebrew</a> package manager tries to do everything as a non-privileged user. The <a href="https://raw.githubusercontent.com/Homebrew/install/master/install">installation script</a> will invoke some commands with <code>sudo</code> &ndash; namely to create and set the correct permissions on <code>/usr/local</code> (its default installation location). Once that is complete, <code>brew install</code> will not require privileged access for installing packages. In fact, the <a href="https://github.com/Homebrew/homebrew/blob/b19d3afccef0ddc31820f1cb7d1a5316017e29df/share/doc/homebrew/FAQ.md#why-does-homebrew-say-sudo-is-bad-">Homebrew project recommends</a> never using <code>sudo</code> with the <code>brew</code> commands.</p>

<p>In Chef 12 the default provider for the <code>package</code> resource is <code>homebrew</code>. This originally came from the <a href="https://supermarket.chef.io/cookbooks/homebrew">homebrew cookbook</a>. In order to not use <code>sudo</code> when managing packages, there&rsquo;s a helper method (mixin) that attempts to determine what non-privileged user should run the <code>brew install</code> command. This is also <a href="https://github.com/opscode/chef/blob/4cb27331d81b394b816278e2bed6b3395b54b9c9/lib/chef/mixin/homebrew_user.rb">ported to Chef 12</a>. The method can also take an argument that specifies a particular user that should run the <code>brew</code> command.</p>

<p>When managing an OS X system with Chef, it is often easier to just run <code>chef-client</code> as <code>root</code>, rather than be around when <code>sudo</code> prompts for a password. This means that we need a way to execute other commands for managing OS X as a non-privileged user. We can reuse the mixin to do this. I&rsquo;ll demonstrate this using plain old Ruby with <code>pry</code>, which is installed in ChefDK, and I&rsquo;ll start it up with <code>sudo</code>. Then, I&rsquo;ll show a short recipe with <code>chef-apply</code>.</p>

<p><code>
% which pry
/opt/chefdk/embedded/bin/pry
% sudo pry
</code></p>

<p>Paste in the following Ruby code:</p>

<p>```ruby
require &lsquo;chef&rsquo;
include Chef::Mixin::HomebrewUser
include Chef::Mixin::ShellOut</p>

<p>find_homebrew_uid #=> 501
```</p>

<p>The method <code>find_homebrew_uid</code> is the helper we want. As we can see, rather than returning <code>0</code> (for <code>root</code>), it returns <code>501</code>, which is the UID of the <code>jtimberman</code> user on my system. To prove that I&rsquo;m executing in a process owned by <code>root</code>:</p>

<p><code>ruby
Process.uid #=&gt; 0
</code></p>

<p>Or, I can shell out to the <code>whoami</code> command using Chef&rsquo;s <code>shell_out</code> method &ndash; which is the same method Chef would use to run <code>brew install</code>.</p>

<p><code>ruby
shell_out('whoami').stdout #=&gt; "root\n"
</code></p>

<p>The <code>shell_out</code> method can take a <code>:user</code> attribute:</p>

<p><code>ruby
shell_out('whoami', :user =&gt; find_homebrew_uid).stdout #=&gt; "jtimberman\n"
</code></p>

<p>So this can be used to install packages with <code>brew</code>, and is exactly what Chef 12 does.</p>

<p><code>ruby
shell_out('brew install coreutils', :user =&gt; find_homebrew_uid)
</code></p>

<p>Or, it can be used to run <code>defaults(1)</code> settings that require running as a specific user, rather than <code>root</code></p>

<p>```ruby</p>

<h1>Turn off iPhoto face detection, please</h1>

<p>shell_out(&lsquo;defaults write com.apple.iPhoto PKFaceDetectionEnabled 0&rsquo;,</p>

<pre><code>      :user =&gt; find_homebrew_uid)
</code></pre>

<p>```</p>

<p>```sh</p>

<h1>before&hellip;</h1>

<p>jtimberman@localhost% defaults read com.apple.iPhoto PKFaceDetectionEnabled
1</p>

<h1>after!</h1>

<p>jtimberman@localhost% defaults read com.apple.iPhoto PKFaceDetectionEnabled
0
```</p>

<p>Putting this together in a Chef recipe that gets run by <code>root</code>, we can disable face detection in iPhoto like this:</p>

<p>```ruby
Chef::Resource::Execute.send(:include, Chef::Mixin::HomebrewUser)</p>

<p>execute &lsquo;defaults write com.apple.iPhoto PKFaceDetectionEnabled 0&rsquo; do
  user find_homebrew_uid
end
```</p>

<p>The first line makes the method available on all <code>execute</code> resources. To make the method available to all resources, use <code>Chef::Resource.send</code>, and to make it available across everything in all recipes, use <code>Chef::Recipe.send</code>. Otherwise we would get a <code>NoMethodError</code> exception.</p>

<p>The <code>execute</code> resource takes a <code>user</code> attribute, so we use the <code>find_homebrew_uid</code> method here to set the user. And we can observe the same results as above:</p>

<p><code>
jtimberman@localhost% defaults write com.apple.iPhoto PKFaceDetectionEnabled 1
jtimberman@localhost% defaults read com.apple.iPhoto PKFaceDetectionEnabled
1
jtimberman@localhost% sudo chef-apply nofaces.rb
Recipe: (chef-apply cookbook)::(chef-apply recipe)
* execute[defaults write com.apple.iPhoto PKFaceDetectionEnabled 0] action run
- execute defaults write com.apple.iPhoto PKFaceDetectionEnabled 0
jtimberman@localhost% defaults read com.apple.iPhoto PKFaceDetectionEnabled
0
</code></p>

<p>Those who have read the workstation management posts on this blog in the past may be aware that I have a <a href="https://supermarket.chef.io/cookbooks/mac_os_x">cookbook</a> that can manage OS X &ldquo;<code>defaults(1)</code>&rdquo; settings. I <a href="https://github.com/chef-osx/mac_os_x/issues/21">plan to make updates</a> to the resource in that cookbook that will leverage this method.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Deleting Attributes]]></title>
    <link href="http://jtimberman.housepub.org/blog/2014/12/24/quicktip-delete-attributes/"/>
    <updated>2014-12-24T10:00:40-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2014/12/24/quicktip-delete-attributes</id>
    <content type="html"><![CDATA[<p>I have a new goal for 2015, and that is to write at least one &ldquo;Quick Tip&rdquo; per week about Chef. I&rsquo;ve added the category &ldquo;<a href="/blog/categories/quicktips">quicktips</a>&rdquo; to make these easier to find.</p>

<p>In this quick tip, I want to talk about a new feature of Chef 12. The new feature is the ability to remove an attribute from all levels (default, normal, override) on a node so it doesn&rsquo;t get saved back to the Chef Server. This was brought up in <a href="https://github.com/opscode/chef-rfc/blob/master/rfc023-chef-12-attributes-changes.md#global-level-removals">Chef RFC 23</a>. The reason I don&rsquo;t want to save the attribute in question back to the server is that it is a secret that I have in a <a href="https://github.com/Nordstrom/chef-vault">Chef Vault item</a>.</p>

<p>I&rsquo;m using <a href="https://www.datadoghq.com">Datadog</a> for my home systems, and the wonderful folks at Datadog have a <a href="https://supermarket.chef.io/cookbooks/datadog">cookbook</a> to set it up. The documentation requires that you set two attributes to authenticate, the API key, and the application key:</p>

<p><code>ruby
node.default['datadog']['api_key'] = 'Secrets In Plain Text Attributes??'
node.default['datadog']['application_key'] = 'It is probably fine.'
</code></p>

<p>I prefer to use chef-vault because <a href="http://jtimberman.housepub.org/blog/2013/09/10/managing-secrets-with-chef-vault/">I think it&rsquo;s the best way</a> to manage shared secrets in Chef recipes. I still need to set the attributes for Datadog&rsquo;s recipe to work, however. In order to accomplish the goal here, I will use a custom cookbook, <code>housepub-datadog</code>. It has one recipe that looks like this:</p>

<p>```ruby
include_recipe &lsquo;chef-vault&rsquo;</p>

<p>node.default[&lsquo;datadog&rsquo;][&lsquo;api_key&rsquo;] = chef_vault_item(:secrets, &lsquo;datadog&rsquo;)[&lsquo;data&rsquo;][&lsquo;api_key&rsquo;]
node.default[&lsquo;datadog&rsquo;][&lsquo;application_key&rsquo;] = chef_vault_item(:secrets, &lsquo;datadog&rsquo;)[&lsquo;data&rsquo;][&lsquo;chef&rsquo;]</p>

<p>include_recipe &lsquo;datadog::dd-agent&rsquo;</p>

<p>ruby_block &lsquo;smash-datadog-auth-attributes&rsquo; do
  block do</p>

<pre><code>node.rm('datadog', 'api_key')
node.rm('datadog', 'application_key')
</code></pre>

<p>  end
  subscribes :create, &lsquo;template[/etc/dd-agent/datadog.conf]&rsquo;, :immediately
end
```</p>

<p>Let&rsquo;s take a closer look at the recipe.</p>

<p><code>ruby
include_recipe 'chef-vault'
</code></p>

<p>Here, the <code>chef-vault</code> recipe is included to ensure everything works, and I have a dependency on <code>chef-vault</code> in my cookbook&rsquo;s metadata. Next, we see the attributes set:</p>

<p><code>ruby
node.default['datadog']['api_key'] = chef_vault_item(:secrets, 'datadog')['data']['api_key']
node.default['datadog']['application_key'] = chef_vault_item(:secrets, 'datadog')['data']['chef']
</code></p>

<p>The <code>secrets/datadog</code> item looks like this in plaintext:</p>

<p>```json
{
  &ldquo;id&rdquo;: &ldquo;datadog&rdquo;,
  &ldquo;data&rdquo;: {</p>

<pre><code>"api_key": "My datadog API key",
"chef": "Application key for the 'chef' application"
</code></pre>

<p>  }
}
```</p>

<p>When Chef runs, it will load the vault-encrypted data bag item, and populate the attributes that will be used in the template. This template comes from the <code>datadog::dd-agent</code> recipe, which is included next. The template from that recipe looks like this:</p>

<p>```ruby
template &lsquo;/etc/dd-agent/datadog.conf&rsquo; do
  owner &lsquo;root&rsquo;
  group &lsquo;root&rsquo;
  mode 0644
  variables(</p>

<pre><code>:api_key =&gt; node['datadog']['api_key'],
:dd_url =&gt; node['datadog']['url']
</code></pre>

<p>  )
end
```</p>

<p>Now, for the grand finale of this post, I delete the attributes that were set using a <code>ruby_block</code> resource. The timing here is important, because these attributes must be deleted after Chef has converged the template. This does get updated every run, because the ruby block is not convergent, and this is okay because the attributes are updated every run, too. I could write additional logic to make this convergent, but I&rsquo;m okay with the behavior. The <code>subscribes</code> ensures that as soon as the template is written, the node object is updated to remove the attributes. Otherwise, this happens next after the <code>dd-agent</code> recipe.</p>

<p>```ruby
ruby_block &lsquo;smash-datadog-auth-attributes&rsquo; do
  block do</p>

<pre><code>node.rm('datadog', 'api_key')
node.rm('datadog', 'application_key')
</code></pre>

<p>  end
  subscribes :create, &lsquo;template[/etc/dd-agent/datadog.conf]&rsquo;, :immediately
end
```</p>

<p>Let&rsquo;s see this in action:</p>

<p>```
managed-node$ chef-client
&hellip;
Recipe: housepub-datadog::default
  * ruby_block[smash-datadog-auth-attributes] action run</p>

<pre><code>- execute the ruby block smash-datadog-auth-attributes
</code></pre>

<p>&hellip;
workstation% knife node show managed-node -a datadog.api_key -a datadog.application_key
managed-node:
  datadog.api_key:
  datadog.application_key:
```</p>

<p><strong>Bonus quick tip!</strong> <code>knife node show</code> can take the <code>-a</code> option multiple times to display more attributes. I just discovered this in writing this post, and I don&rsquo;t know when it was added. For sure in Chef 12.0.3, so you should just upgrade anyway ;).</p>

<p><em>Update</em> This <a href="https://github.com/opscode/chef/commit/4133160972a9972a9a062579504faa40eaa4c8db">feature was added</a> by <a href="https://twitter.com/RanjibDey">Awesome Chef Ranjib Dey</a>.</p>
]]></content>
  </entry>
  
</feed>
