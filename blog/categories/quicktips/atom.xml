<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quicktips | jtimberman's Code Blog]]></title>
  <link href="http://jtimberman.housepub.org/blog/categories/quicktips/atom.xml" rel="self"/>
  <link href="http://jtimberman.housepub.org/"/>
  <updated>2015-05-15T17:02:25-06:00</updated>
  <id>http://jtimberman.housepub.org/</id>
  <author>
    <name><![CDATA[Joshua Timberman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quick Tip: ChefDK Provision]]></title>
    <link href="http://jtimberman.housepub.org/blog/2015/05/15/quick-tip-chefdk-provision/"/>
    <updated>2015-05-15T16:18:03-06:00</updated>
    <id>http://jtimberman.housepub.org/blog/2015/05/15/quick-tip-chefdk-provision</id>
    <content type="html"><![CDATA[<p>Earlier today, <a href="https://www.chef.io/blog/2015/05/15/chefdk-0-6-0-released/">ChefDK 0.6.0 was released</a>. In this post, I will illustrate a fairly simple walkthrough using Amazon EC2, based on information in the <a href="https://github.com/chef/chef-dk/blob/master/PROVISION_README.md#basic-example">document</a>. This example will include Policyfile use, too. Let&rsquo;s get started.</p>

<p>First, install ChefDK 0.6.0. You can get it from the <a href="downloads.chef.io/chef-dk">Chef Downloads page</a>.</p>

<p>Next, setup <a href="https://jtimberman.housepub.org/blog/2013/10/19/managing-multiple-aws-account-credentials/">AWS credentials</a>. Ensure that they are exported to the current shell environment.</p>

<pre><code>AWS_ACCESS_KEY_ID=secrets
AWS_SECRET_ACCESS_KEY=secrets
AWS_DEFAULT_REGION=us-east-1
AWS_SSH_KEY=your_ssh_key_name
AWS_ACCESS_KEY=secrets
AWS_SECRET_KEY=secrets
</code></pre>

<p>I&rsquo;m going to use Hosted Chef as my Chef Server. I already have my user API key and configuration in <code>~/.chef</code>, and I&rsquo;m going to rely on the automatic configuration detection in the <code>chef</code> command for that.</p>

<p>Generate a new repository using the <code>chef generate</code> command. Further commands run from this directory.</p>

<pre><code>chef generate repo chefdk-provision-demo
cd chefdk-provision-demo
</code></pre>

<p>Generate a <code>provision</code> cookbook. This is the required name, and it must be in the current directory.</p>

<pre><code>chef generate cookbook provision
</code></pre>

<p>Edit the default recipe, <code>$EDITOR provision/recipes/default.rb</code>.</p>

<p>```ruby
context = ChefDK::ProvisioningData.context
with_driver &lsquo;aws::us-west-2&rsquo;
options = {
  ssh_username: &lsquo;admin&rsquo;,
  use_private_ip_for_ssh: false,
  bootstrap_options: {</p>

<pre><code>key_name: 'jtimberman',
image_id: 'ami-0d5b6c3d',
instance_type: 'm3.medium',
</code></pre>

<p>  },
  convergence_options: context.convergence_options,
}
machine context.node_name do
  machine_options options
  action context.action
  converge true
end
```</p>

<p>To break this down, first we get the ChefDK provisioning context that will pass in options to <code>chef-provisioning</code>. Then we tell <code>chef-provisioning</code> to use the AWS driver, and in the <code>us-west-2</code> region. The options hash is used to setup the instance. We&rsquo;re using <a href="https://wiki.debian.org/Cloud/AmazonEC2Image/Jessie">Debian 8</a>, which uses the <code>admin</code> user to log in, an SSH key that exists in the AWS region, the actual AMI, and finally the instance type. Then, we&rsquo;re going to set the convergence options automatically from ChefDK. This is the important part that will ensure the node has the right run list.</p>

<p>Generate a <code>Policyfile.rb</code>.</p>

<pre><code>chef generate policyfile
</code></pre>

<p>And edit its content, <code>$EDITOR Policyfile.rb</code>.</p>

<p><code>ruby
name            "chefdk-provision-demo"
default_source  :community
run_list        "recipe[libuuid-user]"
cookbook        "libuuid-user"
</code></p>

<p>Here we&rsquo;re simply getting the <a href="https://supermarket.chef.io/cookbooks/libuuid">libuuid-user cookbook from Supermarket</a> and applying the default recipe to the nodes that have this policy.</p>

<p>The next step is to install the Policyfile. This generates the Policyfile.lock.json, and downloads the cookbooks to the cache, <code>~/.chefdk/cache/cookbooks</code>. If this isn&rsquo;t run, <code>chef</code> will complain, with a reminder to run it.</p>

<pre><code>chef install
</code></pre>

<p>Finally, we can provision a testing system with this policy:</p>

<pre><code>chef provision testing --sync -n debian-libuuid
</code></pre>

<p>This will result in output similar to this:</p>

<pre><code>Uploading policy to policy group testing
Uploaded libuuid-user 1.0.1 (c3220a49)
Compiling Cookbooks...
Recipe: provision::default
  * machine[debian-libuuid] action converge
    - Create debian-libuuid with AMI ami-0d5b6c3d in us-west-2
    - create node debian-libuuid at https://chef-api.example.com/organizations/testing
    -   add normal.tags = nil
    -   add normal.chef_provisioning = {"hash" =&gt; "of options"}
    - waiting for debian-libuuid (i-251f1cec on aws::us-west-2) to be connectable (transport up and running) ...
    - been waiting 60/120 -- sleeping 10 seconds for debian-libuuid (i-251f1cec on aws::us-west-2) to be connectable ...
    - debian-libuuid is now connectable        - generate private key (2048 bits)
    - create directory /etc/chef on debian-libuuid
    - write file /etc/chef/client.pem on debian-libuuid
    - create client debian-libuuid at clients
    -   add public_key = "-----BEGIN PUBLIC KEY-----\n..."
    - Add debian-libuuid to client read ACLs
    - Add debian-libuuid to client update ACLs
    - create directory /etc/chef/ohai/hints on debian-libuuid
    - write file /etc/chef/ohai/hints/ec2.json on debian-libuuid
    - write file /etc/chef/client.rb on debian-libuuid
    - write file /tmp/chef-install.sh on debian-libuuid
    - run 'bash -c ' bash /tmp/chef-install.sh'' on debian-libuuid
    [debian-libuuid] Starting Chef Client, version 12.3.0
                     [2015-05-15T22:42:43+00:00] WARN: Using experimental Policyfile feature
                     resolving cookbooks for run list: ["libuuid-user::default@1.0.1 (c3220a4)", "libuuid-user::verify@1.0.1 (c3220a4)"]
                     Synchronizing Cookbooks:
                       - libuuid-user
                     Compiling Cookbooks...
                     Converging 1 resources
                     Recipe: libuuid-user::default
                       * user[libuuid] action create
                       - create user libuuid

                     Running handlers:
                     Running handlers complete
                     Chef Client finished, 1/1 resources updated in 5.29666495 seconds
    - run 'chef-client -l auto' on debian-libuuid
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Create a Provisioner Node]]></title>
    <link href="http://jtimberman.housepub.org/blog/2015/02/09/quick-tip-create-a-provisioner-node/"/>
    <updated>2015-02-09T20:50:12-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2015/02/09/quick-tip-create-a-provisioner-node</id>
    <content type="html"><![CDATA[<p>This quick tip is brought to you by my preparation for my ChefConf talk about using Chef Provisioning to build a Chef Server Cluster, which is based on my blog post about the same. In the blog post I used chef-zero as my Chef Server, but for the talk I&rsquo;m using Hosted Chef.</p>

<p>In order for the Chef Provisioning recipe to work the provisioning node &ndash; the node that runs chef-client &ndash; needs to have the appropriate permissions to manage objects on the Chef Server. This is easy with chef-zero &ndash; there are no ACLs at all. However in Hosted Chef, like any regular Chef Server, the ACLs don&rsquo;t allow nodes' API clients to modify other nodes, or API clients.</p>

<p>Fortunately we can do all the work necessary using knife, with the <a href="https://github.com/chef/knife-acl">knife-acl</a> plugin. In this quick tip, I&rsquo;ll create a group for provisioning nodes, and give that group the proper permissions for the Chef Provisioning recipe to create the machines' nodes and clients.</p>

<p>First of all, I&rsquo;m using ChefDK, and it&rsquo;s my Ruby environment too, so install the gem:</p>

<p><code>sh
chef gem install knife-acl
</code></p>

<p>Next, use the <code>knife group</code> subcommand to create the new group. Groups are a number of users and/or API clients. By default, an organization on Hosted Chef will have <code>admins</code>, <code>billing-admins</code>, <code>clients</code>, and <code>users</code>. Let&rsquo;s create <code>provisioners</code> now.</p>

<p><code>sh
knife group create provisioners
</code></p>

<p>The Role-based access control (RBAC) system in the Chef Server allows us to assign read, create, update, grant, and delete permissions to various objects in the organization. Containers are a special holder of other types of objects, in this case we need to add permissions for the clients and nodes containers. This is what allows the Chef Provisioning recipe&rsquo;s <code>machine</code> resources to have their Chef objects created.</p>

<p>```sh
for i in read create update grant delete
do
  knife acl add containers clients $i group provisioners
done</p>

<p>for i in read create update grant delete
do
  knife acl add containers nodes $i group provisioners
done
```</p>

<p>Next, we need the API client that will be used by the Chef Provisioning node to authenticate with the Chef Server, and the node needs to be created as well. By default the client will automatically have permissions for the node object that has the same name.</p>

<p><code>sh
knife client create -d chefconf-provisioner &gt; ~/.chef/chefconf-provisioner.pem
knife node create -d chefconf-provisioner
</code></p>

<p>Finally, we need to put the new API client into the provisioners group that was created earlier. First we need to get a mapping of the actors in the organization. Then we can add the client to the group.</p>

<p><code>sh
knife actor map
knife group add actor provisioners chefconf-provisioner
</code></p>

<p>The <code>knife actor map</code> command will generate a YAML file like this:</p>

<h2>```yaml</h2>

<p>:user_map:
  :users:</p>

<pre><code>jtimberman: 12345678901234567890123456780123
</code></pre>

<p>  :usags:</p>

<pre><code>12345678901234567890123456780123: jtimberman
</code></pre>

<p>:clients:
  chefconf-provisioner: chefconf-provisioner
  jtimberman-chefconf-validator: jtimberman-chefconf-validator
```</p>

<p>This maps users to their USAG and stores a list of clients. More information about this is in the <a href="https://github.com/chef/knife-acl/blob/master/README.md">knife-acl README</a></p>

<p>At this point, we have a node, with the private key in <code>~/.chef</code> that can be used with the Chef Server to use Chef Provisioning&rsquo;s <code>machine</code> resource. We can also perform additional tasks that require having a node object, such as create secrets as Chef Vault items:</p>

<p><code>sh
knife vault create secrets dnsimple -M client -J data_bags/secrets/dnsimple.json -A jtimberman -S 'name:chefconf-provisioner'
</code></p>

<p>The entire series of commands is below.</p>

<p>```sh
chef gem install knife-acl
knife group create provisioners</p>

<p>for i in read create update grant delete
do
  knife acl add containers clients $i group provisioners
done</p>

<p>for i in read create update grant delete
do
  knife acl add containers nodes $i group provisioners
done</p>

<p>knife client create -d chefconf-provisioner > ~/.chef/chefconf-provisioner.pem
knife node create -d chefconf-provisioner
knife actor map
knife group add actor provisioners chefconf-provisioner</p>

<p>knife vault create secrets dnsimple -M client -J data_bags/secrets/dnsimple.json -A jtimberman -S &lsquo;name:chefconf-provisioner&rsquo;
```</p>

<p>Hopefully this helps you out with your use of Chef Provisioning, and a non-zero Chef server. If you have further questions, find me at ChefConf!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Define Resources to Notifiy in LWRPs]]></title>
    <link href="http://jtimberman.housepub.org/blog/2015/01/17/quick-tip-define-resources-to-notifiy-in-lwrps/"/>
    <updated>2015-01-17T22:37:06-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2015/01/17/quick-tip-define-resources-to-notifiy-in-lwrps</id>
    <content type="html"><![CDATA[<p>In this quick tip, I&rsquo;ll explain why you may need to create resources to notify in a provider, even if the resource exists in a recipe, when using <code>use_inline_resources</code> in Chef&rsquo;s <a href="http://docs.chef.io/lwrp.html">LWRP DSL</a>.</p>

<p>I&rsquo;ll use an example cookbook, <code>notif</code>, to illustrate. First, I&rsquo;ve created <code>cookbooks/notif/resources/default.rb</code>, with the following content.</p>

<p><code>ruby
actions :write
default_action :write
</code></p>

<p>Then, I have written <code>cookbooks/notif/providers/default.rb</code> like this:</p>

<p>```ruby
use_inline_resources</p>

<p>action :write do
  log &lsquo;notifer&rsquo; do</p>

<pre><code>notifies :create, 'file[notified]'
</code></pre>

<p>  end
end
```</p>

<p>Then the default recipe, where I&rsquo;ll use the resource automatically generated from the resource directory, <code>notif</code>.</p>

<p>```ruby
file &lsquo;notified&rsquo; do
  content &lsquo;something&rsquo;
  action :nothing
end</p>

<p>notif &lsquo;doer&rsquo;
```</p>

<p>When I run Chef, I&rsquo;ll get an error like this:</p>

<p>```
 Recipe: notif::default
   * file[notified] action nothing (skipped due to action :nothing)
   * notif[doer] action write</p>

<pre><code> ================================================================================
 Error executing action `write` on resource 'notif[doer]'
 ================================================================================

 Chef::Exceptions::ResourceNotFound
 ----------------------------------
 resource log[notifer] is configured to notify resource file[notified] with action create, but file[notified] cannot be found in the resource collection. log[notifer] is defined in /tmp/kitchen/cookbooks/notif/providers/default.rb:4:in `block in class_from_file'

 Resource Declaration:
 ---------------------
 # In /tmp/kitchen/cookbooks/notif/recipes/default.rb

  12: notif 'doer'

 Compiled Resource:
</code></pre>

<hr />

<pre><code> # Declared in /tmp/kitchen/cookbooks/notif/recipes/default.rb:12:in `from_file'

 notif("doer") do
   action :write
   retries 0
   retry_delay 2
   default_guard_interpreter :default
   declared_type :notif

   recipe_name "default"
 end
</code></pre>

<p>```</p>

<p>To fix this, I define the <code>file</code> resource in the provider:</p>

<p>```ruby
use_inline_resources</p>

<p>action :write do
  log &lsquo;notifer&rsquo; do</p>

<pre><code>notifies :create, 'file[notified]'
</code></pre>

<p>  end</p>

<p>  file &lsquo;notified&rsquo; do</p>

<pre><code>content new_resource.name
</code></pre>

<p>  end
end
```</p>

<p>Then when I run Chef, it will converge and notify the file resource to be configured.</p>

<p>```
Recipe: notif::default
  * file[notified] action nothing (skipped due to action :nothing)
  * notif[doer] action write</p>

<pre><code>* log[notifer] action write

* file[notified] action create
  - create new file notified
  - update content in file notified from none to 935e8e
  --- notified       2015-01-18 05:47:49.186399317 +0000
  +++ ./.notified20150118-15795-om5fiw       2015-01-18 05:47:49.186399317 +0000
  @@ -1 +1,2 @@
  +doer
* file[notified] action create (up to date)
</code></pre>

<p>Running handlers:
Running handlers complete
Chef Client finished, &frac34; resources updated in 1.298990565 seconds
```</p>

<h2>Why does this happen?</h2>

<p>The reason for this is because <code>use_inline_resources</code> tells Chef that in this provider, we&rsquo;re using inline resources that will be added to their own run context, with their own resource collection. We don&rsquo;t have access to the resource collection from the recipe. Even though the <code>file[notified]</code> resource exists from the recipe, it doesn&rsquo;t actually get inherited in the provider&rsquo;s run context, raising the error we saw before.</p>

<p>We can turn off <code>use_inline_resources</code> by removing it, and the custom resource will be configured:</p>

<p>```ruby
action :write do
  log &lsquo;notifer&rsquo; do</p>

<pre><code>notifies :create, 'file[notified]'
</code></pre>

<p>  end
end
```</p>

<p>Then run Chef:</p>

<p>```
Recipe: notif::default
  * file[notified] action nothing (skipped due to action :nothing)
  * notif[doer] action write (up to date)
  * log[notifer] action write
  * file[notified] action create</p>

<pre><code>- update content in file notified from 935e8e to 3fc9b6
--- notified 2015-01-18 05:47:49.186399317 +0000
+++ ./.notified20150118-16159-r18q7z 2015-01-18 05:50:57.832140405 +0000
@@ -1,2 +1,2 @@
-doer
+something
</code></pre>

<p>```</p>

<p>Notice that the <code>file[notified]</code> resource wasn&rsquo;t updated at the start of the run, when it was encountered in the recipe, but it was when notified by the log resource in the provider action, changing the content.</p>

<h2>Use inline compile mode!</h2>

<p>The <code>use_inline_resources</code> method in the lightweight provider DSL is strongly recommended. It makes it easier to send notifications from the custom resource itself to other resources in the recipe&rsquo;s resource collection. Read more about the <a href="http://docs.chef.io/lwrp.html#inline-compile-mode">inline compile mode</a> in the Chef docs.</p>

<p>Also, define the resources that you need to notify when you&rsquo;re doing this in your provider&rsquo;s actions. A common example is within a provider that writes configuration for a service, and needs to tell that service to restart.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Testing Conditionals in ChefSpec]]></title>
    <link href="http://jtimberman.housepub.org/blog/2015/01/12/quick-tip-testing-conditionals-in-chefspec/"/>
    <updated>2015-01-12T14:07:06-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2015/01/12/quick-tip-testing-conditionals-in-chefspec</id>
    <content type="html"><![CDATA[<p>This tip is brought to you by the <a href="https://supermarket.chef.io/cookbooks/homebrew">homebrew</a> cookbook.</p>

<p><a href="http://sethvargo.github.io/chefspec/">ChefSpec</a> is a great way to create tests for Chef recipes to catch regressions. Sometimes recipes end up having branching conditional logic that can have very different outcomes based on external factors &ndash; attributes, existing system state, or cross-platform support.</p>

<p>The homebrew cookbook only supports OS X, so we don&rsquo;t have cross-platform support to test there. However, its default recipe has four conditionals to test. You can read the entire <a href="https://github.com/opscode-cookbooks/homebrew/blob/master/spec/recipes/default_spec.rb">default_spec.rb</a> for full context, I&rsquo;m going to focus on just one aspect here:</p>

<ul>
<li>Installing homebrew should only happen if the <code>brew</code> binary does not exist.</li>
</ul>


<p>This is a common use case in Chef recipes. The best way to go about converging your node to the desired state involves running some arbitrary command. In this case, it&rsquo;s the installation of Homebrew itself. Normally for installations we want to use an idempotent, convergent resource like <code>package</code>. However, since homebrew is to be our package management system, we have to do something else. As it turns out the homebrew project provides an installation script and that script will install a binary, <code>/usr/local/bin/brew</code>. We will assume that if Chef converged on a node after running the script, and the <code>brew</code> binary exists, then we don&rsquo;t need to attempt reinstallation. There&rsquo;s more robust ways to go about it (e.g., running <code>brew</code> gives some desired output), but this works for example purposes today.</p>

<p>From <a href="https://github.com/opscode-cookbooks/homebrew/blob/master/recipes/default.rb">the recipe</a>, here&rsquo;s the resource:</p>

<p><code>ruby
execute 'install homebrew' do
  command homebrew_go
  user node['homebrew']['owner'] || homebrew_owner
  not_if { ::File.exist? '/usr/local/bin/brew' }
end
</code></p>

<p><code>command</code> is a script, called <code>homebrew_go</code>, which is a local variable set to a path in <code>Chef::Config[:file_cache_path]</code>. It is retrieved in the recipe with <code>remote_file</code>. The resource used to have <code>execute homebrew_go</code>, but when ChefSpec runs, it does so in a random temporary directory, which we cannot predict the name.</p>

<p>The astute observer will note that the <code>user</code> parameter has another conditional (designated by the <code>||</code>). That&rsquo;s actually the subject of another post. In this post, I&rsquo;m concerned only with testing the guard, <code>not_if</code>.</p>

<p>The <code>not_if</code> is a Ruby block, which means the Ruby code is evaluated inline during the Chef run. How we go about testing that is the subject of this post.</p>

<p>First, we need to mock the return result of sending the <code>#exist?</code> method to the <code>File</code> class. There are two reasons. First, we want to control the conditional so we can write a test for each outcome. Second, someone running the test (like me) might have already installed homebrew on their local system (which I have), and so <code>/usr/local/bin/brew</code> will exist. To do this, in our context, we have a <code>before</code> block that stubs the return to false:</p>

<p><code>ruby
before(:each) do
  allow_any_instance_of(Chef::Resource).to receive(:homebrew_owner).and_return('vagrant')
  allow_any_instance_of(Chef::Recipe).to receive(:homebrew_owner).and_return('vagrant')
  allow(File).to receive(:exist?).and_return(false)
  stub_command('which git').and_return(true)
end
</code></p>

<p>There&rsquo;s some other mocked values here. I&rsquo;ll talk about the <code>vagrant</code> user for <code>homebrew_owner</code> in a moment, though again, that&rsquo;s the subject of another post.</p>

<p>The actual spec will test that the installation script will actually get executed when we run chef, and as the <code>vagrant</code> user.</p>

<p>```ruby
it &lsquo;runs homebrew installation as the default user&rsquo; do
  expect(chef_run).to run_execute(&lsquo;install homebrew&rsquo;).with(</p>

<pre><code>:user =&gt; 'vagrant'
</code></pre>

<p>  )
end
```</p>

<p>When rspec runs, we see this is the case:</p>

<p>```
homebrew::default
  default user</p>

<pre><code>runs homebrew installation as the default user
</code></pre>

<p>```</p>

<p>If I didn&rsquo;t mock the user, it would be <code>jtimberman</code>, as that is the user that is running Chef via rspec/ChefSpec. The test would fail. If you&rsquo;re looking at the full file, there&rsquo;s some other details we&rsquo;re going to look at shortly. If I didn&rsquo;t mock the return for <code>File.exist?</code>, the execute wouldn&rsquo;t run at all.</p>

<p>To test what happens when <code>/usr/local/bin/brew</code> exists, I set up a new context in rspec, and create a new <code>before</code> block.</p>

<p>```ruby
context &lsquo;/usr/local/bin/brew exists&rsquo; do
  before(:each) do</p>

<pre><code>allow(File).to receive(:exist?).and_return(true)
stub_command('which git').and_return(true)
</code></pre>

<p>  end</p>

<p>  it &lsquo;does not run homebrew installation&rsquo; do</p>

<pre><code>expect(chef_run).to_not run_execute('install homebrew')
</code></pre>

<p>  end
end
```</p>

<p>We don&rsquo;t need the <code>vagrant</code> mocks earlier, but we do need to stub <code>File.exist?</code>. This test would pass on my system without it, but not on, e.g., a Linux system that doesn&rsquo;t have homebrew.</p>

<p>Then running rspec, we see:</p>

<p>```
homebrew::default
  /usr/local/bin/brew exists</p>

<pre><code>does not run homebrew installation
</code></pre>

<p>  default user</p>

<pre><code>runs homebrew installation as the default user
</code></pre>

<p>```</p>

<p>In a coming post, I will walk through the conditionals related to the <code>homebrew_owner</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quick Tip: Serverspec spec_helper in Test Kitchen]]></title>
    <link href="http://jtimberman.housepub.org/blog/2014/12/31/quick-tip-serverspec-spec-helper-in-test-kitchen/"/>
    <updated>2014-12-31T16:01:23-07:00</updated>
    <id>http://jtimberman.housepub.org/blog/2014/12/31/quick-tip-serverspec-spec-helper-in-test-kitchen</id>
    <content type="html"><![CDATA[<p>Recently, I&rsquo;ve started refactoring some <a href="https://supermarket.chef.io/cookbooks/daemontools">old</a> <a href="https://supermarket.chef.io/cookbooks/djbdns">cookbooks</a> <a href="https://supermarket.chef.io/cookbooks/ucspi-tcp">I wrote</a> ages ago. I&rsquo;m adding Serverspec coverage that can be run with <code>kitchen verify</code>. In this <a href="/blog/categories/quicktips">quicktip</a>, I&rsquo;ll describe how to create a <code>spec_helper</code> that can be used in all the specs. This is a convention used by <a href="http://pivotallabs.com/spec-helper/">many</a> in the Ruby community to add configuration for RSpec.</p>

<p>For Chef, we can run integration tests after convergence using <a href="http://kitchen.ci">Test Kitchen</a> using Serverspec. To do that, we need to require Serverspec, and then set its backend. In some cookbooks, the author/developer may have written <code>spec_helper</code> files in the various <code>test/integration/SUITE/serverspec/</code> directories, but this will use a single shared file for them all. Let&rsquo;s get started.</p>

<p>In the <code>.kitchen.yml</code>, add the <code>data_path</code> configuration directive in the provisioner.</p>

<p><code>yaml
provisioner:
  name: chef_zero
  data_path: test/shared
</code></p>

<p>Then, create the <code>test/shared</code> directory in the cookbook, and create the <code>spec_helper.rb</code> in it.</p>

<p><code>sh
mkdir test/shared
$EDITOR test/shared/spec_helper.rb
</code></p>

<p>Minimally, it should look like this:</p>

<p>```ruby
require &lsquo;serverspec&rsquo;</p>

<p>set :backend, :exec
```</p>

<p>Then in your specs, for example <code>test/integration/default/serverspec/default_spec.rb</code>, require the <code>spec_helper</code>. On the instances under test, the file will be copied to <code>/tmp/kitchen/data/spec_helper.rb</code>.</p>

<p><code>ruby
require_relative '../../../kitchen/data/spec_helper'
</code></p>

<p>That&rsquo;s it, now when running <code>kitchen test</code>, or <code>kitchen verify</code> on a converged instance, the helper will be used.</p>
]]></content>
  </entry>
  
</feed>
